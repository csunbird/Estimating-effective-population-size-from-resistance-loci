// Initialize parameters
initialize() {
	
	defineConstant("NUM_COMBINATIONS", 27);
	//defineConstant("NUM_GENERATIONS", 10000);
	defineConstant('ge_length', 10000); //10kb haplotype 
	defineConstant('sweep_site', integerDiv((ge_length + 1), 2)); //just roughly middle of vgsc gene
	defineConstant('low_site', sweep_site - 1);
	defineConstant('high_site', 1 + sweep_site);
	
	
	//initialise mutations
	//initialise VGSC sweep mutation
	//1.0 selection coeff, complete dominance, fixed fitness effect
	mutationStackPolicy = "l";
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeMutationType("m2", 1.0, "f", 1.0); // introduced sweep mutation

	
	
	// Initialize arrays to store simulation parameters
	N_values = integer(27, fill1=0);
	mutation_rates = float(27);
	recombination_rates = float(27);
	burn_in_files = string(27);
	
	// Read parameter combinations from parameter combinations.txt file
	i = 0;
	file = readFile("C:/CHEYANNE STUFF/ICL Biology/Year 3/Final year project/Estimating-effective-population-size-from-resistance-loci/simulations/parameter_combinations.txt");
	file = file[substr(file, 0, 1) != "N,"];
	
	for (line in file) {
		tokens = strsplit(line, sep= ",");
		//print("Line:"+ line); 
		//print("Tokens:"+ tokens);  
		N_values[i] = asInteger(tokens[0]);
		mutation_rates[i] = asFloat(tokens[1]);
		recombination_rates[i] = asFloat(tokens[2]);
		burn_in_files[i] = asInteger(tokens[3]);
		i = i + 1;
		}
		
		//Get job array index from command line
		array_index = PBS_ARRAY_INDEX;
		print(type(array_index));
		// Convert the index to an integer
		//array_index = strToInt(array_index);
		
		// Set parameters for current combination
		N = N_values[array_index];
		mu = mutation_rates[array_index];
		r = recombination_rates[array_index];
		
		initializeMutationRate(mu);
		initializeRecombinationRate(r);
		defineConstant('pop_size', N);
	
	//seed is 
	seedID = seed;
	}
	
				
// Main simulation, label sweep start as s1
		s1 1 early() ;{
		
		
		//print out parameters for checking on job logfile
		print("for Array Index, seed:" + array_index + ','+ seedID);
		print("population size:" + pop_size);
		print ("recombination rate:" + recombination_rate);
		print("mutation rate:" + mut_rate);
		print("genome size:" + ge_length);
		
// Read burn-in population from file
sim.readFromPopulationFile(burn_in_files[array_index]);
			sweep = sim.mutationsOfType(m1);
			
		
		// Modify mutation to sweep
		target = sample(p1.genomes, 1);
		target.addNewDrawnMutation(m2, 10000)
		
		//calculate heterozygosity
		1000:100000 late(){
			heterozygosity = calcHeterozygosity(sim.subpopulations.individuals.genomes);
			if (heterozygosity >= 0.8 ) {
				sim.simulationFinished();
				catn(seedID + ': swept to 80%');
				catn('number of generations taken: ' + sim.cycle);
				sim.treeSeqOutput("combination_" + current_combination + "_" + seedID+ "_simulation.trees");
			
			}
			//else 
		}
		
		// Additional late() block for cutoff time point
		100000 late(){
			catn(seedID + ":TIME EXPIRED");
			sim.simulationFinished();
			sim.treeSeqOutput("combination_" + current_combination + "_" + seedID+ "_expired.trees");
		}
	}
	
	
	//setSeed 1-10 per each array_index
			seeds = readFile("C:/CHEYANNE STUFF/ICL Biology/Year 3/Final year project/Estimating-effective-population-size-from-resistance-loci/simulations/seeds.txt");
			for (seed in seeds) {
				seedID = seed;
				setSeed(seedID);
				initialize() {};
				sim.s1

}
