// Initialize parameters
initialize() {
	// Use tree-sequence recording to speed up burn-in
	initializeTreeSeq();
	//defineConstant("seedID", 1811758731);
	defineConstant("NUM_COMBINATIONS", 27);
	defineConstant('ge_length', 10000); //10kb haplotype 
	defineConstant('sweep_site', 5000); //just roughly middle of vgsc gene, at position 5000
	defineConstant('low_site', sweep_site - 1);
	defineConstant('high_site', 1 + sweep_site);
	
	
	//initialise mutations
	//initialise VGSC sweep mutation
	//1.0 selection coeff, complete dominance, fixed fitness effect
	mutationStackPolicy = "l";
	initializeMutationType("m0", 0.5, "f", 0.0); //neutral mutation
	initializeMutationType("m1", 0.5, "f", 0.02); // introduced sweep mutation dominance is likely partial 
	//selection coeff could be 0.02. Khatri et al (the best fit selection coefficient as  0:017)
	
	// Initialize genomic types
	initializeGenomicElementType('g1', m0, 1.0);
	initializeGenomicElement(g1, 0, low_site);
	initializeGenomicElement(g1, high_site, ge_length);
	initializeGenomicElementType('g2', m1, 1.0);
	initializeGenomicElement(g2, sweep_site, sweep_site);
	
	
	// Initialize arrays to store simulation parameters
	N_values = integer(27, fill1=0);
	mutation_rates = float(27);
	recombination_rates = float(27);
	burn_in_files = integer(27, fill1=0);
	
	// Read parameter combinations from parameter combinations.txt file
	i = 0;
	file = readFile("parameter_combinations.txt");
	file = file[substr(file, 0, 1) != "N,"];
	
	for (line in file) {
		tokens = strsplit(line, sep= ",");
		//print("Line:"+ line); 
		//print("Tokens:"+ tokens);  
		N_values[i] = asInteger(tokens[0]);
		mutation_rates[i] = asFloat(tokens[1]);
		recombination_rates[i] = asFloat(tokens[2]);
		burn_in_files[i] = asInteger(tokens[3]);
		i = i + 1;
	}
	
	// Set parameters for current combination
	N = N_values[array_index-1];
	mu = mutation_rates[array_index-1];
	r = recombination_rates[array_index-1];
	
	initializeMutationRate(mu);
	initializeRecombinationRate(r);
	defineConstant('pop_size', N);
	
	//seed is 
	setSeed(seedID);
	print("seedID: " + seedID);
	
	//print out parameters for checking on job logfile
	print("for Array Index, seed:" + array_index + ','+ seedID);
	print("population size:" + pop_size);
	print ("recombination rate:" + r);
	print("mutation rate:" + mu);
	print("genome size:" + ge_length);


}

// define function to calculate population heterozygosity (correct version)
function (float)estimatepop_Heterozygosity(o<Subpopulation>$ subpop)
{
	sum =0;
	div=0;
	for (individual in sim.subpopulations.individuals) {
		sum = sum + calcPairHeterozygosity(individual.genome1, individual.genome2, infiniteSites = T);
	}
	div = sum/pop_size;
	return div;
}





// Main simulation, label sweep start as s1

1 late() {
	// Read burn-in population from file
	sim.readFromPopulationFile("burnin_no." + array_index + "_complete.trees");
	
	//setting tick number from the read in population file back to 1
	//community.tick=1;
	//sim.cycle = 1
	catn('starting cycle no.: ' + sim.cycle);

	// logfile
	log = community.createLogFile(array_index + '_'+ seedID +".csv", logInterval=1000);
	log.addCustomColumn("Array Index", "array_index;");
	log.addCustomColumn("SeedID", "seedID;");
	log.addCycle();
	log.addCustomColumn("Heterozygosity", "estimatepop_Heterozygosity(p0);");

	// Add and modify mutation to sweep
	sweep = sim.mutationsOfType(m1);
	target = sample(p0.genomes, 1); //chooses one genome in the subpopulation to add the sweep mutation into
	target.addNewDrawnMutation(m1, 5000); //add sweep mutation m1 at position 5000 in target genome

	// calculate heterozygosity
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('starting generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
}

//calculate heterozygosity at set timepoints

10000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

15000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

20000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

25000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

30000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

35000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

40000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

45000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

50000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

55000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

60000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

70000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

80000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

90000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

100000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}


110000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

120000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

130000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

130000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

140000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

150000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

160000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

170000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

180000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

190000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

200000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}


250000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}


300000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

350000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

400000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

450000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

500000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

600000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

700000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		//sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_simulation.trees");
	
	}
	//else 
}

800000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_complete_simulation.trees");
	
	}
	//else 
}

900000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', seed_ID: ' + seedID + ', heterozygosity: ' + heterozygosity);
	if (heterozygosity >= 0.8 ) {
		sim.simulationFinished();
		catn(array_index +','+ seedID + ': swept to 80%');
		catn('number of generations taken: ' + sim.cycle);
		
		//output random sample of individuals from population as vcf files? 
		// or use outputMutations() and outputFixedMutations() for whole population BUT not in vcf format
		p0.outputVCFSample(pop_size, outputMultiallelics = T, filePath = array_index + '_'+ seedID +'.vcf',  simplifyNucleotides = F);
		sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_complete_simulation.trees");
	
	}
	//else 
}

// Additional late() block for cutoff time point at 1000k 
1000000 late(){
	heterozygosity = estimatepop_Heterozygosity(p0);
	catn('generation: ' + sim.cycle +', heterozygosity: ' + heterozygosity);
	catn("array index, seedID: "+ array_index + "," + seedID + " TIME EXPIRED");
	sim.simulationFinished();
	sim.treeSeqOutput("combination_" + array_index + "_" + seedID + "_expired.trees");
}